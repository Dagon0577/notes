# 学习内容 2019-07-01
- [ER图与建表语句](#ER图与建表语句)
- [详细讲解各个事务隔离级别与优缺点最好用生活化的语言描述、举例。](#事务隔离级别)
- [死锁的根本原因是什么；怎么处理死锁；怎么规避死锁](#死锁)
- [二段锁](https://segmentfault.com/a/1190000012513286)
---
## ER图与建表语句
    use test;
    create table if not exists book 
    (
        id int not null primary key,
        name char(16)  null,
        author char(16) null,
        pubComp date null,
        count int null,
        price decimal
    );

    create table if not exists record
    (
        id int not null primary key,
        bId int not null,
        rId int not null,
        willDate date null,
        returnDate date null,
        lendDate date null
    );

    create table if not exists reader
    (
        id int not null primary key,
        name char(16) null,
        lendNum int null
    );

    create table if not exists penalty
    (
        id int not null primary key,
        bId int not null,
        type char(16) null,
        pDate date null,
        price char(16) null
    );

    create index rIndex on record (id,bId,rId);


## 事务隔离级别

- **`Read uncommitted：`**  
    读未提交，顾名思义，就是`一个事务可以读取另一个未提交事务的数据`。

    事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

    分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是`脏读`。

    那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。
---
- **`Read committed：`**
    读提交，顾名思义，就是`一个事务要等另一个事务提交后才能读取数据`。

    事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了`（第二次检测金额当然要等待妻子转出金额事务提交完）`。程序员就会很郁闷，明明卡里是有钱的…

    分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了`一个事务范围内两个相同的查询却返回了不同数据`，这就是`不可重复读`。

    那怎么解决可能的不可重复读问题？Repeatable read ！
---

- **`Repeatable read`**
    重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

    事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时`（事务开启，不允许其他事务的UPDATE修改操作）`，收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

    分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，`不可重复读对应的是修改，即UPDATE操作`。但是可能还会有幻读问题。因为`幻读问题对应的是插入INSERT操作，而不是UPDATE操作`。

    什么时候会出现幻读？

    事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即`新增INSERT`了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

    那怎么解决幻读问题？Serializable！
---

- **`Serializable`**

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

---
`值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。`

## 死锁
当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就会出现死锁，严重影响应用的正常执行。 

`常见的死锁情况与解决方案:`


- 一、 事务之间对资源访问顺序的交替  
    出现原因：   
    一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

    解决方法：   
    这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。



- 二. 并发修改同一记录  
    - 出现原因：  
    　  用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁由于比较隐蔽，但在稍大点的项目中经常发生。

      一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S)锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。

    - 解决方法：   
      a. 使用`乐观锁`进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。

      b. 使用`悲观锁`进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。  

      c. SqlServer可支持更新锁 
      为解决死锁，SqlServer引入更新锁,它有如下特征： 
        (1) 加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。 
        (2) 解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。 
        (3) 与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。 

            更新锁的意思是：“我现在只想读，你们别人也可以读，但我将来可能会做更新操作，我已经获取了从共享锁（用来读）到排他锁（用来更新）的资格”。一个事物只能有一个更新锁获此资格。 
            T1执行select，加更新锁。 
            T2运行，准备加更新锁，但发现已经有一个更新锁在那儿了，只好等。 
            当后来有user3、user4…需要查询table表中的数据时，并不会因为T1的select在执行就被阻塞，照样能查询,提高了效率。

- 三. 索引不当导致全表扫描  
    - 出现原因： 
    如果在事务中执行了一条不满足条件的语句，执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。  

    - 解决方法： 
    SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。

- 四.事务封锁范围大且相互等待


`死锁发生的条件`：   
1、资源不能共享，需要只能由一个进程或者线程使用   
2、请求且保持，已经锁定的资源自给保持着不释放   
3、不剥夺，自给申请到的资源不能被别人剥夺   
4、循环等待  


`防止死锁`的途径就是避免满足死锁条件的情况发生，适合这个问题解决的方案有:   
1、保持事务简短并在一个批处理中 
在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。   

2、使用低隔离级别 
确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺（比如这次的S NK和X IK 是InnoDB引擎Repeatable Read级别才有的）。